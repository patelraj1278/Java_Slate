##https://www.developer.com/microsoft/start-using-java-lambda-expressions/
Lambda Expressions Syntax
The basic syntax of a lambda is either:

(parameters) ->expression                or         (parameters) ->{ statements; }

The following are examples of Java lambda expressions:

1.  () -> 5                           		// takes no value and returns 5
2.  x -> 2 * x            					// takes a number and returns the result of doubling it
3.  (x, y) -> x – y                     		// takes two numbers and returns their difference
4.  (int x, int y) -> x + y      				// takes two integers and returns their sum
5.  (String s) -> System.out.print(s) 		// takes a string and prints it to console without returning anything

##https://mkyong.com/tutorials/java-8-tutorials/
Let us see the six basic function interfaces.

Interface	        Signature	            Examples
UnaryOperator<T>	T apply(T t)	        String::toLowerCase, Math::tan
BinaryOperator<T>	T apply(T t1, T t2)	    BigInteger::add, Math::pow
Function<T, R>	    R apply(T t)	        Arrays::asList, Integer::toBinaryString
Predicate<T, U>	    boolean test(T t, U u)	String::isEmpty, Character::isDigit
Supplier<T>	        T get()	                LocalDate::now, Instant::now, TreeMap::new
Consumer<T>	        void accept(T t)	    System.out::println, Error::printStackTrace

Java 8 Function examples
Java 8 BiFunction examples
Java 8 BinaryOperator examples
Java 8 UnaryOperator Examples
Java 8 Predicate examples
Java 8 BiPredicate examples
Java 8 Consumer examples
Java 8 BiConsumer examples
Java 8 Supplier Examples


#https://mkyong.com/java8/java-8-method-references-double-colon-operator/

There are four kinds of method references:

Reference to a static method ClassName::staticMethodName
Reference to an instance method of a particular object Object::instanceMethodName
Reference to an instance method of an arbitrary object of a particular type ContainingType::methodName–
Reference to a constructor ClassName::new

In Java 8, the double colon (::) operator is called method references. Refer to the following examples:

Anonymous class to print a list.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(new Consumer<String>() {       // anonymous class
    @Override
    public void accept(String str) {
        System.out.println(str);
    }
});
Anonymous class -> Lambda expressions.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(str -> System.out.println(str)); // lambda
Lambda expressions -> Method references.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(System.out::println);          // method references
Anonymous Class -> Lambda expression -> Method Reference


#Function Interface

---Function.java

@FunctionalInterface
public interface Function<T, R> {

      R apply(T t);

}
T – Type of the input to the function.
R – Type of the result of the function.



In Java 8, BiFunction is a functional interface; it takes two arguments and returns an object.

---BiFunction.java

@FunctionalInterface
public interface BiFunction<T, U, R> {

      R apply(T t, U u);

}
T – Type of the first argument to the function.
U – Type of the second argument to the function.
R – Type of the result of the function.


The UnaryOperator takes one argument, and returns a result of the same type of its arguments.

---UnaryOperator.java

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}
The Function takes one argument of any type and returns a result of any type.

Function.java

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

In Java 8, BinaryOperator is a functional interface and it extends BiFunction.

The BinaryOperator takes two arguments of the same type and returns a result of the same type of its arguments.

---BinaryOperator.java

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T> {
}
The BiFunction takes two arguments of any type, and returns a result of any type.

BiFunction.java

@FunctionalInterface
public interface BiFunction<T, U, R> {
      R apply(T t, U u);
}


In Java 8, Predicate is a functional interface, which accepts an argument and returns a boolean. Usually, it used to apply in a filter for a collection of objects.
-----Predicate.java

@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}


In Java 8, BiPredicate is a functional interface, which accepts two arguments and returns a boolean, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the test.

-----BiPredicate.java
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}

In Java 8, Consumer is a functional interface; it takes an argument and returns nothing.

----Consumer.java
@FunctionalInterface
public interface Consumer<T> {
  void accept(T t);
}

In Java 8, BiConsumer is a functional interface; it takes two arguments and returns nothing.

---BiConsumer.java
@FunctionalInterface
public interface BiConsumer<T, U> {
  void accept(T t, U u);
}


In Java 8, Supplier is a functional interface; it takes no arguments and returns a result.

----Supplier.java

@FunctionalInterface
public interface Supplier<T> {
    T get();
}

#Lambda Expression
    Method Reference
    Constructor Reference
    Static Reference

#Java 8 Functional Interface
    #Java 8 Function
        LongToIntFunction
        DoubleToIntFunction
        IntToLongFunction
        DoubleToLongFunction
        IntToDoubleFunction
        LongToDoubleFunction
        Function<T,R>
        IntFunction<R>
        LongFunction<R>
        DoubleFunction<R>
        ToIntFunction<T>
        ToLongFunction<T>
        ToDoubleFunction<T>
    #Java 8 BiFunction
        BiFunction<T,U,R>
        ToIntBiFunction<T,U>
        ToLongBiFunction<T,U>
        ToDoubleBiFunction<T,U>
    #Java 8 BinaryOperator
        IntBinaryOperator
        LongBinaryOperator
        DoubleBinaryOperator
        BinaryOperator<T>
    #Java 8 UnaryOperator
        IntUnaryOperator
        LongUnaryOperator
        DoubleUnaryOperator
        UnaryOperator<T>
    #Java 8 Predicate
        IntPredicate
        LongPredicate
        DoublePredicate
        Predicate<T>
    #Java 8 BiPredicate
        BiPredicate<T,U>
    #Java 8 Consumer
        IntConsumer LongConsumer
        DoubleConsumer Consumer<T>
        ObjIntConsumer<T>
        ObjLongConsumer<T>
        ObjDoubleConsumer<T>
    #Java 8 BiConsumer
        BiConsumer<T,U>
    #Java 8 Supplier
        IntSupplier
        LongSupplier
        DoubleSupplier
        BooleanSupplier
        Supplier<T>


#Java 8 Streams



#Java 8 Comparator<T>
    -Comparator factory methods
        comparing and variants of primitives naturalOrder and reverseOrder
        null friendly Comparator
    -Combining Comparators thenComparing and reverse

#Java 8 Optional<T>
    Some convenient methods
        Optional.ofNullable()
        Optional.empty()
        Optional.of()
        void ifPresent(Consumer<T> action)
        boolean isPresent()
        T orElse(T other)
        T orElseGet(Supplier<T> supplier)
        Optional<T> filter(Predicate<T> test)
        Optional<U> map(Function<T,U> mapper)
        Optional<U> flatMap(Function<T, Optional<U>> mapper)
    Where does Java Optional fits?
        Method Parameter
        Method Return Type
        Constructor Parameter
        Variable Declaration
        Class Level

#Java 8 Spliterator and its primitive variants
    Spliterator<E>
    IntSpliterator
    LongSpliterator
    DoubleSpliterator

#Java 8 Statistics, StringJoiner
    IntSummaryStatistics
    LongSummaryStatistics
    DoubleSummaryStatistics
    StringJoiner