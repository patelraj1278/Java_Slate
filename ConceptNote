##https://www.developer.com/microsoft/start-using-java-lambda-expressions/
Lambda Expressions Syntax
The basic syntax of a lambda is either:

(parameters) ->expression                or         (parameters) ->{ statements; }

The following are examples of Java lambda expressions:

1.  () -> 5                           		// takes no value and returns 5
2.  x -> 2 * x            					// takes a number and returns the result of doubling it
3.  (x, y) -> x – y                     		// takes two numbers and returns their difference
4.  (int x, int y) -> x + y      				// takes two integers and returns their sum
5.  (String s) -> System.out.print(s) 		// takes a string and prints it to console without returning anything

##https://mkyong.com/tutorials/java-8-tutorials/
Let us see the six basic function interfaces.

Interface	        Signature	            Examples
UnaryOperator<T>	T apply(T t)	        String::toLowerCase, Math::tan
BinaryOperator<T>	T apply(T t1, T t2)	    BigInteger::add, Math::pow
Function<T, R>	    R apply(T t)	        Arrays::asList, Integer::toBinaryString
Predicate<T, U>	    boolean test(T t, U u)	String::isEmpty, Character::isDigit
Supplier<T>	        T get()	                LocalDate::now, Instant::now, TreeMap::new
Consumer<T>	        void accept(T t)	    System.out::println, Error::printStackTrace

Java 8 Function examples
Java 8 BiFunction examples
Java 8 BinaryOperator examples
Java 8 UnaryOperator Examples
Java 8 Predicate examples
Java 8 BiPredicate examples
Java 8 Consumer examples
Java 8 BiConsumer examples
Java 8 Supplier Examples


#https://mkyong.com/java8/java-8-method-references-double-colon-operator/

There are four kinds of method references:

Reference to a static method ClassName::staticMethodName
Reference to an instance method of a particular object Object::instanceMethodName
Reference to an instance method of an arbitrary object of a particular type ContainingType::methodName–
Reference to a constructor ClassName::new

In Java 8, the double colon (::) operator is called method references. Refer to the following examples:

Anonymous class to print a list.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(new Consumer<String>() {       // anonymous class
    @Override
    public void accept(String str) {
        System.out.println(str);
    }
});
Anonymous class -> Lambda expressions.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(str -> System.out.println(str)); // lambda
Lambda expressions -> Method references.


List<String> list = Arrays.asList("node", "java", "python", "ruby");
list.forEach(System.out::println);          // method references
Anonymous Class -> Lambda expression -> Method Reference


#Function Interface

---Function.java

@FunctionalInterface
public interface Function<T, R> {

      R apply(T t);

}
T – Type of the input to the function.
R – Type of the result of the function.



In Java 8, BiFunction is a functional interface; it takes two arguments and returns an object.

---BiFunction.java

@FunctionalInterface
public interface BiFunction<T, U, R> {

      R apply(T t, U u);

}
T – Type of the first argument to the function.
U – Type of the second argument to the function.
R – Type of the result of the function.


The UnaryOperator takes one argument, and returns a result of the same type of its arguments.

---UnaryOperator.java

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}
The Function takes one argument of any type and returns a result of any type.

Function.java

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

In Java 8, BinaryOperator is a functional interface and it extends BiFunction.

The BinaryOperator takes two arguments of the same type and returns a result of the same type of its arguments.

---BinaryOperator.java

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T> {
}
The BiFunction takes two arguments of any type, and returns a result of any type.

BiFunction.java

@FunctionalInterface
public interface BiFunction<T, U, R> {
      R apply(T t, U u);
}


In Java 8, Predicate is a functional interface, which accepts an argument and returns a boolean. Usually, it used to apply in a filter for a collection of objects.
-----Predicate.java

@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}