
========================
#Core Java
========================
Overloading & Overriding
Static binding & Dynamic Binding
Abstract class & Interface
this & super keyword in Java
Private Method
Static Method
Final Method
Exception
String Class
Immutable Class & Object
Comparator & Comparable
Equals & Hashcode Method
Enum
Singleton
Collection Interface
Thread Concept
Transient & Volatile Keyword
Serialization
IO Concept
JDK Version
Dead Lock & Race Condition
JVM
When class is loaded
Design Pattern


Java Pass by Value & Pass by Reference
Composition In Java
Nested classes
Access modifier

DataTypes
Try-Catch-Finally
Member Types : instance variables, class variables, intance method, class method (static) , contructors,initilizer block,class initilizer block, static nested class,inner class,member interface
Object class
Member of Interface

========================
#Concept Hacks
========================

-OOPS Concepts
    -Encapsulation in Java
         Important points about encapsulation in Java.
         1. "Whatever changes encapsulate it" is a famous design principle.
         2. Encapsulation helps in loose coupling and high cohesion of code.
         3. Encapsulation in Java is achieved using access modifiers private, protected, and public.
         4. Factory pattern, Singleton pattern in Java makes good use of Encapsulation.
    -Polymorphism in Java
        -something which can take many forms
        -In Java programming whole concept of interface is based on Polymorphism
        -Java has excellent support of polymorphism in terms of Inheritance, method overloading, and method overriding.
        -Method overriding allows Java to invoke a method based on a particular object at run-time instead of declared type while coding.
        -Method overloading and method overriding use concept of Polymorphism in Java where method name remains the same in two classes but an actual method called by JVM depends upon an object at run time and done by dynamic binding in Java.
    -Inheritance
        -The class which extends another class becomes Child of the class it extends and inherits all its functionality which is not private or package-private given where Child class is created.
        -Java Sub Class IS-A Super class like Mango IS-A Fruit.
        -Inheritance in Java is supported using extends and implements keyword
        -If you do not want to allow Inheritance for your class than you can make it final.
        -Constructor in Java are not inherited by Sub Class. In face Constructors are chained, first statement in constructor is always a call to another constructor, either implicitly or explicitly. If you don't call any other constructor compiler will insert super(), which calls no argument constructor of super class in Java. this keyword represents the current instance of a class and the super keyword represent an instance of super class in Java.
        -Private members of Super class is not visible to Sub class.
        -Java has a special access modifier known as protected which is meant to support Inheritance in Java. Any protected member including protected method and field are only accessible in Child class or Sub class outside the package on which they are declared.
        When to Use Inheritance ?
            -Policy to decide whether to use Inheritance or not is to check "IS-A" relationship. For example, all above examples of Inheritance satisfy IS-A rule e.g. HashSet IS-A Set.
             Conversely if you find HAS-A relationship between two classes than use Composition e.g. Car HAS-A Seat, So Car class should be composed with a Seat and Seat should not extend Car here.
    -Abstraction
        -An abstract class is something which is incomplete and you can not create an instance of the abstract class. If you want to use it you need to make it complete or concrete by extending it. A class is called concrete if it does not contain any abstract method and implements all abstract method inherited from the abstract class or interface it has implemented or extended.
        -An abstract method in Java doesn't have the body , it's just a declaration. In order to use an abstract method, you need to override that method in sub class.
        -when do you use abstraction? ( most important in my view )
            when you know something needs to be there but not sure how exactly it should look like.
        -Abstraction Using Interface in Java.Interfaces are by default abstract and only contains public, static, final constant or abstract methods
        -ABSTRACT - If you know some of the behavior while designing class and that would remain common across all subclasses add that into an abstract class.
        -INTERFACE - you can go for java interface if you only know the name of methods your class should have e.g. for Server it should have start() and stop() method but we don't know how exactly these start and stop method will work.
        -It's not necessary for an abstract class to have abstract method. We can mark a class as abstract even if it doesn't declare any abstract methods.There is only one case where I think abstract class without abstract method can be used is when you need a marker class instead of marker interface
#Class Name
-the public class name must match the file name
-Remember class is a blueprint while objects are real instances
#Method Overloading & Overriding
-Method overloading is resolved using static binding in Java at compile time while method overriding is resolved using dynamic binding in Java at runtime.
-You can not override static, final, and private methods in Java but you can overload static, final, or private methods in Java.
-The overriding method can not throw a higher Exception than the original or overridden method.This means if the original method throws IOException then the overriding method can not throw super class of IOException like Exception but it can throw any sub-class of IOException or simply does not throw an Exception.This rule only applies to check Exception in Java, overridden method is free to throw any unchecked Exception.
-you're allowed to change the return type in the overriding method as long as the new return type is a subtype of the declared return type of the overridden (super class)
class Alpha { Alpha doStuff(char c) { return new Alpha(); } } class Beta extends Alpha { Beta doStuff(char c) { // legal override in Java 1.5 return new Beta(); } }
#Constructor Overloading
-Classical example of Constructor overloading is ArrayList in Java. ArrayList has three constructors one is empty, the other takes a collection object and one takes initial Capacity. these overloaded constructors allow flexibility while creating an ArrayList object.
#Static Binding vs Dynamic Binding - https://javahungry.blogspot.com/2018/11/method-overriding-in-java-with-examples.html
-Static binding in Java occurs during Compile time while Dynamic binding occurs during Runtime.private, final and static methods and variables use static binding and are bonded by the compiler while virtual methods are bonded during runtime based upon runtime object.
-Static binding uses Type(Class in Java)  information for binding while Dynamic binding uses Object to resolve to bind.
-Overloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.
#Variable Shadowing & Hiding - https://javahungry.blogspot.com/2020/02/variable-shadowing-and-variable-hiding.html
#Interface
-the interface is the only way to implement multiple inheritances at the Type level.
-All variables declared inside interface is implicitly public final variable or constants.
-All abstract,static, default methods declared inside Java Interfaces are implicitly public and abstract.Java 8 onwards, it can have default as well as static methods.It is not mandatory to override the default method in Java
#Abstraction
-An abstract class allows you to create functionality that subclasses can implement or override. An interface only allows you to define functionality, not implement it.And whereas a class can extend only one abstract class, it can take advantage of multiple interfaces.
-An abstract class - Multiple Inheritance is not supported , Interface supports Multiple Inheritance.
-Both top level and nested class can be make abstract in Java
-Diff Abstract vs Interfact -> https://www.tutorialspoint.com/differences-between-abstract-class-and-interface-in-java
-The marker interface in Java interfaces with no field or methods or, in simple words empty interface in java is called a marker interface
Example of marker interface is Serializable, Cloneable, and Remote interface.Looking carefully at marker interfaces in Java, like, Serializable, Cloneable, and Remote, it looks they are used to indicate something to compiler or JVM. So if JVM sees a Class is Serializable, it has done some special operation on it, a similar way, if JVM sees one Class is implement Cloneable, it performs some operation to support cloning.
#this Keyword
-"this" keyword can not be used in static context.this is a final variable in Java and you can not assign value to this. this will result in a compilation error:
#Private Keyword
-Private members (both fields and methods) are only accessible inside class they are declared or inside inner classes.
-Top level classes can not be private in Java.
-private methods are well encapsulated in class
-you cannot override private methods in Java
-private keyword can be applied to fields, methods and inner class in Java.
-private methods or variables are not accessible outside of Class, they can be accessed via reflection by using setAccessible(true) and changing there private visibility.
-private members allows Compiler and JVM to optimize it for better performance.
#Static Variable,Static Method,Static Nested Class in Java
-Can create static method, static class and static variable in Java
-static keyword is like any other keyword a simple keyword which can be applied to Java method , nested class or member variable inside a class. static variable in Java belong to whole Class than individual Object
-there is only one copy of static variable will be present in Java Heap memory, which can be accessed or altered by any object.
-you can not use non-static variable inside a static method.it will result in compilation error.
-Static variables are bonded using static binding at compile time so they are comparatively faster than there non-static counter part which were bonded during runtime.
-static variable initialized when class is loaded into JVM on the other hand instance variable has a different value for each instance and they get created when an instance of an object is created either by using the new() operator or using reflection like Class.newInstance().So if you try to access a non-static variable without any instance compiler will complain because those variables are not yet created and they don't have any existence until an instance is created and they are associated with any instance
-A static variable is shared by all instances of the class, while an instance variable is unique to each instance of the class.
-A static variable's memory is allocated at compile time, they are loaded at load time and initialized at class initialization time. In the case of an instance variable all of the above is done at run time.
-You can still access any non-static variable inside any static method or block by creating an instance of class in Java and using that instance to reference instance variable. This is the only legitimate way to access non static variable on static context.
-Static fields are initialized at the time of class loading in Java, opposite to instance variable which is initialised when you create instance of a particular class.
-Static keyword can also be used to create static block in Java which holds piece of code to executed when class is loaded in Java.
-Static method can not be overridden in Java as they belong to class and not to object.so if you have same static  method in subclass and super class , method will be invoked based on declared type of object instead of runtime .If you try to override a static method with a non-static method in sub class you will get compilation error.
-Consider making a static variable final in Java to make it constant and avoid changing it from anywhere in the code.
-Nested static class in Java is a static member of any top level class.
-Since to create instance of any nested class you require instance of outer class but that is not required in case of static nested class in Java.You can have an instance of nested static class without any instance of outer class.
-Normally we make a class static in Java when we want a single resource to be shared between all instances
#Mixing - Static and non-static synchronized method Java
-For those who are not familiar static synchronized method locked on class object e.g. for string class, it's String.class while instance synchronized method locks on the current instance of Object denoted by “this” keyword in Java.Since both of these objects are different they have a different lock so while one thread is executing the static synchronized method, the other thread in java doesn’t need to wait for that thread to return instead it will acquire a separate lock denoted byte .class literal and enter into the static synchronized method.
public class SynchornizationMistakes {
    private static int count = 0;

    //locking on this object lock
    public synchronized int getCount(){
        return count;
    }

    //locking on .class object lock
    public static synchronized void increment(){
        count++;
    }
}
#Final Keyword in Java
-Once you make a reference final you are not allowed to change that reference and compiler will verify this and raise a compilation error if you try to re-initialized final variables in Java.
-Final variables are by default read-only.
-A Java method with the final keyword is called a final method and it can not be overridden in the subclass.You should make a method final in Java if you think it’s complete and its behavior should remain constant in sub-classes.
-Java class with the final modifier is called the final class in Java. The final class is complete in nature and can not be sub-classed or inherited.
-Final keyword improves performance. Not just JVM can cache the final variables but also applications can cache frequently use final variables
-Final variables are safe to share in a multi-threading environment without additional synchronization overhead.
-Final keyword allows JVM to an optimized method, variable or class.
-Final keyword helps to write an immutable class. Immutable classes are the one which can not be modified once it gets created and String is a primary example of an immutable and final class
-The local final variable must be initialized during declaration.
-All variables declared inside the Java interface are implicitly final
-Final and abstract are two opposite keywords and a final class can not be abstract in Java.
-Final methods are bonded during compile time also called static binding.
-Making a collection reference variable final means only reference can not be changed but you can add, remove or change object inside collection.
private final List loans = new ArrayList();
loans.add(“home loan”);  //valid
loans.add("personal loan"); //valid
loans = new Vector();  //not valid
#Checked vs Unchecked Exception in Java
-Checked Exception in Java is all those Exception which requires being catches and handled during compile time.
-All the Exception which are direct sub Class of Exception but not inherit RuntimeException are Checked Exception.
-Example of checked Exception in Java API
 Following are some Examples of Checked Exception in Java library:
 IOException
 SQLException
 DataAccessException
 ClassNotFoundException
 InvocationTargetException
-Unchecked Exception in Java is those Exceptions whose handling is not verified during Compile time. Unchecked Exceptions mostly arise due to programming errors like accessing the method of a null object, accessing elements outside an array bonding, or invoking methods with illegal arguments.
Example of unchecked Exception in Java API
Here are few examples of Unchecked Exception in Java library:
NullPointerException
ArrayIndexOutOfBound
IllegalArgumentException
IllegalStateException

Rule 1. The overriding method can throw any unchecked(runtime) exception regardless of whether the overridden method declares the exception.
Rule 2. The overriding method must not throw checked exceptions that are new or broader than those declared by the overridden method. For example, a method that declares a FileNotFoundException can not be overridden by a method that declares a SQLException, Exception, or any other non-runtime exception unless it's a subclass of FileNotFoundException.
The overriding method can throw narrower or fewer exceptions. Just because an overridden method "takes risks" doesn't mean that the overriding subclass' exception takes the same risks.
Bottom line: an overriding method doesn't have to declare any exceptions that it will never throw, regardless of what the overridden method declares.
#How to write immutable class in Java
-This Java class is immutable because its state can not be changed once created. You can see that all of it’s fields are final.
-Immutable objects are by default thread safe, can be shared without synchronization in concurrent environment.
-An immutable object simplifies development, because its easier to share between multiple threads without external synchronization.
#Comparator vs Comparable
-compareTo in Java is in the same league of equals() and hashcode() and used to implement natural order of object, compareTo is slightly different to compare() method of Comparator interface which is used to implement custom sorting order.
-compareTo() method is defined in interface java.lang.Comparable and it is used to implement natural sorting on java classes. natural sorting means the sort order which naturally applies on object e.g. lexical order for String, numeric order for Integer or Sorting employee by there ID, etc
-CompareTo method must return negative number if current object is less than other object, positive number if current object is greater than other object and zero if both objects are equal to each other.
#Equal and Hashcode
-equals() method is used to compare Objects for equality while hashCode is used to generate an integer code corresponding to that object.
-Default implementation of equals() class provided by java.lang.Object compares memory location and only return true if two reference variable is pointing to the same memory location i.e. essentially they are the same object.
-HashMap and Hashtable in Java rely on the equals() and hashCode() method for comparing keys and values

#Equals and hashCode contract in Java
Equals Rule
1) Reflexive: Object must be equal to itself.
2) Symmetric : if a.equals(b) is true then b.equals(a) must be true.
3) Transitive : if a.equals(b) is true and b.equals(c) is true then c.equals(a) must be true.
if((obj == null) || (obj.getClass() != this.getClass())) { return false; }

Hashcode Rule
1) If two objects are equal by equals() method then there hashcode must be same.
2) If two objects are not equal by equals() method then there hashcode could be same or different.


#Enum
-A feature that is used to represent a fixed number of well-known values in Java
-The best feature of Enum is you can use Enum in Java inside Switch statements like int or char primitive data type.
-Two new collection classes EnumMap and EnumSet are added to the collection package to support Java Enum.These classes are a high-performance implementation of the Map and Set interface in Java and we should use this whenever there is an opportunity.
Enum in Java is type-safe, provides meaningful String names and has their own namespace
Enum constants - Enum constants are implicitly static and final and you can not change their value once created.
Enum is type-safe you can not assign anything else other than predefined Enum constants to an Enum variable. It is a compiler error to assign something else
Enum in Java are reference types like class or interface and you can define constructor, methods, and variables inside java Enum which makes it more powerful than Enum
Enum - Variable
Enum - Method
Enum - Constructor - The constructor of the enum in java must be private any other access modifier will result in a compilation error.You can not create an instance of enums by using a new operator
Enum Instance - An instance of Enum in Java is created when any Enum constants are first called or referenced in code.
Enum Interface - An instance of Enum in Java is created when any Enum constants are first called or referenced in code.
Enum Abstract Method - You can define abstract methods inside Enum in Java.and can also provide a different implementation for different instances of enum in java.
Enum built-in Method - Enum has so many useful built-in methods like values(), the valueOf(), name(), and ordinal(),
Enum can override methods also.
Real-world Examples of Enum in Java - Enum as Thread Safe Singleton,Strategy Pattern using Enum,Enum as replacement of Enum String or int pattern,Enum as State Machine

#Singleton
-Singleton is a class which has only one instance in whole application and provides a getInstance() method to access the singleton instance.
There are many classes in JDK which is implemented using Singleton pattern like java.lang.Runtime which provides getRuntime() method to get access of it and used to get free memory and total memory in Java.
-Since locking only make sense when we need to create instance and rest of the time its just read only access so locking of critical section is always better option.synchronization is costly and when you apply this on whole method than call to getInstance() will be synchronized and contented.
-there are many ways to implement Singleton like using double checked locking or Singleton class with static final instance initialized during class loading. Former is called lazy loading because Singleton instance is created only when client calls getInstance() method while later is called early loading because Singleton instance is created when class is loaded into memory.
Double checked locking is a technique to prevent creating another instance of Singleton when call to getInstance() method is made in multi-threading environment. In Double checked locking pattern as shown in below example, singleton instance is checked two times before initialization.
public static Singleton getInstance(){
     if(_INSTANCE == null){
         synchronized(Singleton.class){
         //double checked locking - because second check of Singleton instance with lock
                if(_INSTANCE == null){
                    _INSTANCE = new Singleton();
                }
            }
         }
     return _INSTANCE;
}
Ways to create Singleton -
1)Double checked locking should only be used when you have requirement for lazy initialization
2)use Enum to implement singleton or simple static final variable.
3)Preferred way is not to implement Cloneable interface as why should one wants to create clone() of Singleton and if you do just throw Exception from clone() method as “Can not create clone of Singleton class”.
4)Since constructor of Singleton class is supposed to be private it prevents creating instance of Singleton from outside but Reflection can access private fields and methods, which opens a threat of another instance. This can be avoided by throwing Exception from constructor as “Singleton already initialized”

How many ways you can write Singleton Class in Java?
Answer : I know at least four ways to implement Singleton pattern in Java
Singleton by synchronizing getInstance() method
Singleton with public static final field initialized during class loading.
Singleton generated by static nested class, also referred as Singleton holder pattern.
From Java 5 on-wards using Enums

#String class in Java
https://www.journaldev.com/1321/java-string-interview-questions-and-answers
-The string is Immutable in Java because String objects are cached in the String pool. Since cached String literals are shared between multiple clients there is always a risk, where one client's action would affect all other clients. For example, if one client changes the value of the String "Test" to "TEST", all other clients will also see that value as explained in the first example. Since caching of String objects was important for performance reasons this risk was avoided by making the String class Immutable.
At the same time, String was made final so that no one can compromise invariant of String class like Immutability, Caching, hashcode calculation, etc by extending and overriding behaviors.
-Since Strings are very popular as the HashMap key, it's important for them to be immutable so that they can retrieve the value object which was stored in HashMap. Since HashMap works in the principle of hashing, which requires the same has value to function properly. Mutable String would produce two different hashcodes at the time of insertion and retrieval if contents of String were modified after insertion, potentially losing the value object in the map.
-Why String is Final in Java? Answer
1) String Pool - String Pool is a pool of Strings stored in Java heap memory.Imagine String pool facility without making string immutable, it's not possible at all because in the case of string pool one string object/literal e.g. "Test" has referenced by many reference variables, so if any one of them change the value others will be automatic gets affected.
2) Security - In case, if String is not immutable, this would lead serious security threat, I mean someone can access any file for which he has authorization, and then can change the file name either deliberately or accidentally and gain access to that file.
3) Thread safety Since String is immutable it can safely share between many threads which are very important for multithreaded programming and to avoid any synchronization issues in Java, Immutability also makes String instance thread-safe in Java, which means you don't need to synchronize String operation externally.
4) Caching- Another reason Why String is immutable in Java is to allow String to cache its hashcode, being immutable String in Java caches its hashcode, and do not calculate every time we call the hashcode method of String, which makes it very fast as a hashmap key to be used in hashmap in Java.
-Since Strings are immutable in Java if you store the password as plain text it will be available in memory until the Garbage collector clears it and since String is used in the String pool for reusability there is a pretty high chance that it will remain in memory for a long duration, which poses a security threat.
-Since Strings are immutable there is no way the contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his elements as blank or zero. So Storing the password in a character array clearly mitigates security risk of stealing passwords.
-Many Java programmer makes the mistake of using "==" for string comparison. "==" just check if two reference variables are pointing two same objects in Java heap and since String is immutable in Java and maintained in String pool two String literal refer same String object which gives the sense that "==" can be used to compare string which is incorrect. always use equals() method for equality check and compare method for actual string comparison.
-how do you manipulate String in Java without creating String garbage? StringBuilder and StringBuffer are the answer to this question.
-StringBuffer is an old class but StringBuilder is newly added in Java 5 along with major improvements

-String : Immutability offers a lot of benefits to the String class e.g. his hashcode value can be cached which makes it a faster hashmap key and one of the reasons why String is a popular key in HashMap. Because String is final it can be safely shared between multiple threads without any extra synchronization.When we represent a string in double quotes like "abcd" they are referred as String literal and String literals are created in String pools. When you compare two String literals using equality operator "==" it returns true because they are the actual same instance of String.
-StringBuffer:The String object is immutable in Java but StringBuffer and StringBuilder are mutable objects.StringBuffer is synchronized while StringBuilder is not which makes StringBuilder faster than StringBuffer.
-StringBuilder :Concatenation operator "+" is internally implemented using either StringBuffer or StringBuilder.
Note : Use String if you require immutability, use StringBuffer in java if you need mutable + thread-safety, and use StringBuilder in Java if you require mutable + without thread-safety.
What is the String pool in Java? -When the Java program creates a new String using String literal, JVM checks for that String in the pool and if String literal is already present in the pool then the same object is returned instead of creating a whole new object.
String pool check is only performed when you create String as literal, if you create String using the new() operator, a new String object will be created even if String with the same content is available in the pool.
Intern method : the String object created by the new() operator is by default not added in the String pool as opposed to String literal. The intern method allows putting a String object into a pool.


#Thread
-Thread vs Runnable - Java doesn't support multiple inheritances, which means you can only extend one class in Java so once you extended the Thread class you lost your chance and can not extend or inherit another class in Java.
The Runnable interface represents a Task that can be executed by either plain Thread or Executors or any other means. so logical separation of Task as Runnable than Thread is a good design decision.
-How to make Thread in Java?
There are two ways of implementing threading in Java
1) By extending java.lang.Thread class, or
2) By implementing java.lang.Runnable interface. -> Override public void run() method
-Java thread is state based so it remains in predefined state at any given time and state transition occurs by calling different thread method.
-Thread will be said to go on dead state once execution of run() method finished and you can not start that thread again.
-you can not call start() method twice on the thread object.once started, the second call of start() will throw IllegalStateException
-only difference between the start() and run() method in Thread is that start creates a new thread while the run doesn't create any thread and simply executes in the current thread like a normal method call.
Thread State -NEW,RUNNABLE,WAIT,TIMED WAIT,BLOCK,TERMINATED
-Make code Thread-Safe in Java -
    Use the synchronized keyword in Java ,
    Use Atomic Integer since atomic operations are thread-safe,
    Immutable objects are by default thread-safe because their state can not be modified once created e.g. Read-only or final variables in Java
    Atomic operations in Java are thread-safe
    local variables are also thread-safe because each thread has there own copy
    Volatile keyword in Java can also be used to instruct thread not to cache variables and read from main memory and can also instruct JVM not to reorder or optimize code from threading perspective.
    Example of thread-safe class in Java: Vector, Hashtable, ConcurrentHashMap, String, etc.
-Synchronization in Java is possible by using the Java keywords "synchronized" and "volatile”.
-Concurrent access of shared objects in Java introduces two kinds of errors: thread interference and memory consistency errors and to avoid these errors you need to properly synchronize your Java object to allow mutual exclusive access of critical section to two threads.
-The synchronized keyword in Java provides locking, which ensures mutually exclusive access to the shared resource and prevents data race.
-synchronized keyword involves locking and unlocking. before entering into a synchronized method or block thread needs to acquire the lock, at this point it reads data from main memory than cache and when it releases the lock, it flushes write operation into main memory which eliminates memory inconsistency errors.
-Instead of synchronized variable in Java, you can have java volatile variable, which will instruct JVM threads to read the value of the volatile variable from main memory and don’t cache it locally.
-Block synchronization in Java is preferred over method synchronization
-static synchronized method locked on class object lock and nonstatic synchronized method locks on current object (this).
-you can not use Java synchronized keyword with constructor
-You cannot apply java synchronized keyword with variables
-Daemon thread in Java is those thread that runs in the background and is mostly created by JVM for performing background tasks like Garbage collection and other housekeeping tasks.
-Any thread created by the main thread, which runs the main method in Java is by default non-daemon because Thread inherits its daemon nature from the Thread which creates.It will remain non-daemon until explicitly made daemon by calling setDaemon(true).
-Thread.setDaemon(true) makes a Thread daemon but it can only be called before starting Thread in Java. It will throw IllegalThreadStateException if the corresponding Thread is already started and running.
Difference between Daemon and Non-Daemon thread in Java
    1) JVM doesn't wait for any daemon thread to finish before existing.
    2) Daemon Thread is treated differently than User Thread when JVM terminates, finally, blocks are not called, Stacks are not unwounded and JVM just exits.
-Difference between Wait and Sleep, Yield in Java -
-sleep() and yield() methods are defined in thread class while wait() is defined in the Object class.
-This difference is more obvious from the fact that, when a thread calls the wait() method, it releases the monitor or lock it was holding on that object, but when a thread calls the sleep() method, it never releases the monitor even if it is holding.
-yield(), it's little different than wait() and sleep(), it just releases the CPU hold by Thread to give another thread an opportunity to run though it's not guaranteed who will get the CPU.It totally depends upon thread scheduler and it's even possible that the thread which calls the yield() method gets the CPU again.
-Thread.sleep() method is a static method and applies on the current thread, while wait() is an instance-specific method and only got wake up if some other thread calls notify method on the same object. waiting thread can be awake by calling notify and notifyAll while sleeping thread can not be awakened by calling notify method.
-The major difference between yield and sleep in Java is that yield() method pauses the currently executing thread temporarily for giving a chance to the remaining waiting threads of the same priority to execute. If there is no waiting thread or all the waiting threads have a lower priority then the same thread will continue its execution.
-Unlike wait() method in Java, sleep() method of Thread class doesn't relinquish the lock it has acquired.

Sleep (Thread Class static method)- sleep() method of Thread class doesn't relinquish the lock it has acquired.
Yield (Thread Class instance method)- Release CPU hold by Thread to give another thread an opportunity to run.it's even possible that the thread which calls the yield() method gets the CPU again.
Wait (Object Class instance method)- when a thread calls the wait() method, it releases the monitor or lock it was holding on that object
Notify,NotifyAll (Object Class instance method)-  Wait and notify is not just normal methods or synchronization utility, more than that they are communication mechanism between two threads in Java. And Object class is the correct place to make them available for every object if this mechanism is not available via any java keyword like synchronized.
Join - This java thread join method puts the current thread on wait until the thread on which it’s called is dead. If the thread is interrupted, it throws InterruptedException.

-Wait and notify is not just normal methods or synchronization utility, more than that they are communication mechanism between two threads in Java. And Object class is the correct place to make them available for every object if this mechanism is not available via any java keyword like synchronized.
-Locks are made available on per Object basis, which is another reason wait and notify is declared in Object class rather then Thread class.
-if we don't call wait() or notify() method from synchronized context we will receive IllegalMonitorStateException in Java
-wait(), notify(), or notifyAll() method mostly for inter-thread communication in Java
-Calling notify() or notifyAll() methods issues a notification to a single or multiple threads that a condition has changed and once the notification thread leaves the synchronized block, all the threads which are waiting for fight for object lock on which they are waiting and lucky thread returns from wait() method after reacquiring the lock and proceed further.
-notify() method doesn't provide any way to choose a particular thread, that's why it's only useful when you know that there is only one thread is waiting.
-notifyAll() sends a notification to all threads and allows them to compete for locks, which ensures that at least one thread will proceed further.

Produce Consumer thread example to understand the scenario better:

   1. The Producer thread tests the condition (buffer is full or not) and confirms that it must wait (after finding buffer is full).

   2. The Consumer thread sets the condition after consuming an element from a buffer.

   3. The Consumer thread calls the notify () method; this goes unheard since the Producer thread is not yet waiting.

   4. The Producer thread calls the wait () method and goes into a waiting state.

How to Stop Thread in Java-
    Earlier there was a stop method that exists in Thread Class but Java deprecated that method citing some safety reasons.
    Using a flag to stop Thread is a very popular way of stopping the thread and it's also safe because it doesn't do anything special rather than helping run() method to finish itself.
    Thread in Java will stop once the run() method is finished. Another important point is that you can not restart a Thread which run() method has finished already, you will get an IllegalStateException
Processes vs Threads -
    Threads are used for small tasks, whereas processes are used for more ‘heavyweight’ tasks – basically the execution of applications.
    a thread could be considered a ‘lightweight’ process
    a process can consist of multiple threads,

Volatile Keyword
-You can use the Volatile variable if you want to read and write long and double variables atomically. long and double both are 64-bit data types and by default writing of long and double is not atomic and platform dependence.
-A volatile variable can be used as an alternative way of achieving synchronization in Java in some cases, like Visibility. with volatile variable, it's guaranteed that all reader threads will see the updated value of the volatile variable once the write operation is completed, without volatile keyword different reader thread may see different values.
-volatile variable can be used to inform the compiler that a particular field is subject to be accessed by multiple threads, which will prevent the compiler from doing any reordering or any kind of optimization which is not desirable in a multi-threaded environment.

Serialization
-Java serialization is the process which is used to serialize an object in java by storing an object’s state into a file with an extension .ser and recreating object's state from that file, this reverse process is called deserialization.
-Object Serialization in Java is a process used to convert Object into a binary format which can be persisted into a disk or sent over the network to any other running Java virtual machine;the reverse process of creating object from the binary stream is called deserialization in Java.
-Java provides Serialization API for serializing and deserializing object which includes java.io.Serializable, java.io.Externalizable, ObjectInputStream and ObjectOutputStream etc.
-Making a class Serializable in Java is very easy, Your Java class just needs to implements java.io.Serializable interface and JVM will take care of serializing objects in the default format.
-It doesn't have any method and also called Marker Interface in Java.
-If you don't want any field to be part of object's state then declare it either static or transient based on your need and it will not be included during Java serialization process.
-Java Serialization is done by java.io.ObjectOutputStream class.To store any object via serialization mechanism we call ObjectOutputStream.writeObject(saveThisobject) and to deserialize that object we call ObjectInputStream.readObject() method.
-serialization & Externalizable - In the case of Serializable, the default serialization process is used.the case of Externalizable custom Serialization process is used which is implemented by the application.Externalizable interface provides complete control of serialization process to application. readExternal() and writeExternal() supersede any specific implementation of writeObject and readObject methods.


Transient Keyword
Static variables are not serialized ( atleast with standard serializers ) so there is no sense marking a variable static as well as transient.
Marking final variable as transient will disable its participation in serialization or deserialization. Final has no relevance with transient in terms of serialization.

Transient vs Volatile
-transient keyword is used along with instance variables to exclude them from the serialization process. if a field is transient its value will not be persisted.For example, if you have a field called "interest" whose value can be derived from other fields like principal, rate, time, etc then there is no need to serialize it.Another good example of a transient keyword is "Logger" since most of the time you have a logger instance for logging in Java but you certainly don't want it to serialize
-volatile keyword can also be used in variables to indicate compiler and JVM that always read its value from the main memory and follow happens-before relationship on the visibility of volatile variables among multiple threads.Volatile only ensures that the access is atomically, while Atomics ensure that the operation is atomically

Atomicity, Visibility and Ordering
Atomicity - : it is usually thought of in terms of mutual exclusion.
Visibility - Visibility determines when the effects of one thread can be seen by another.
Ordering - Ordering determines when actions in one thread can be seen to occur out of order with respect to another.

Advantage of a new Lock interface
-The major advantage of lock interfaces on multi-threaded and concurrent programming is they provide two separate locks for reading and writing which enables you to write high-performance data structures

Common problems you have faced in multi-threading environment
-Memory-interference, race conditions, deadlock, livelock, and starvation are an example of some problems comes in multi-threading and concurrent programming.

Thread Concurrency -Callable & FutureTask
-Callable's call() method can return value and throw Exception, which was not possible with Runnable's run() method.
-A FutureTask object can be used to wrap a Callable or Runnable object. Since FutureTask also implements Runnable, it can be submitted to an Executor for execution.The result can only be retrieved when the computation has been completed; the get methods will block if the computation has not yet been completed.
-The main difference between these two is that Callable's call() method can return value and throw Exception, which was not possible with Runnable's run() method. Callable return Future object, which can hold the result of the computation.


Thread Pool
-Thread pool is a pool of already created worker thread ready to do the job.
-Thread pool in Java is a pool of worker threads, which is ready to perform any task given to them, mostly in the form of implementation of Runnable or Callable interface.
-One example of using a thread pool is creating a web server, which processes client requests.
-If only one thread is used to process client requests then it subsequently limits how many clients can access the server concurrently. In order to support a large number of clients, you may decide to use one thread per request paradigm, in which each request is processed by a separate thread, but this requires Thread to be created when the request arrived.  Since the creation of Thread is a time-consuming process, it delays request processing.
It also limits the number of clients based upon how many threads per JVM is allowed, which is obviously a limited number. Thread pool solves this problem for you, It creates Threads and manages them. Instead of creating Thread and discarding them once the task is done, thread-pool reuses threads in form of a worker thread.
-The core of this thread pool framework is Executor interface which defines an abstraction of task execution with method execute(Runnable task) and ExecutorService which extends Executor to add various life-cycle and thread pool management facilities like shutting down thread pool.
-Executor framework also provides a static utility class called Executors ( similar to Collections) which provides several static factory methods to create various types of Thread Pool implementation in Java e.g. fixed-size thread pool, cached thread pool, and scheduled thread pool. Runnable and Callable interfaces are used to represent tasks executed by worker thread managed in these Thread pools.


ConcurrentHashMap - https://javarevisited.blogspot.com/2020/09/10-examples-of-concurrenthashmap-in-java.html#axzz7PaXJVRPl
putIfAbsent- This is a useful method that can be used to only insert elements if it's not already present in the map or dictionary.

Race conditions - occur when two threads operate on the same object without proper synchronization and their operation interleaves on each other.The Classical example of the Race condition is incrementing a counter since increment is not an atomic operation and can be further divided into three steps like reading, update, and write.
What is a deadlock? - when two or more threads are waiting for each other to release the resource they need (lock) and get stuck for infinite time, the situation is called deadlock. It will only happen in the case of multitasking or multi-threading.

Difference between JRE, JDK, and JVM
In short, there are few differences between JRE, JDK, and JVM:

1)  JRE and JDK come as installers while JVM is bundled with them.
2)  JRE only contains an environment to execute a java program but doesn’t contain other tools for compiling a java program.
3)  JVM comes along with both JDK and JRE and is created when you execute the Java program by giving the “java” command.

When class is loaded in Java - static initialization.
When a class is initialized in Java -After class loading, initialization of the class takes place which means initializing all static members of the class.
1) an instance of the class is created using either a new() keyword or using reflection using class.forName(), which may throw ClassNotFoundException in Java.
2) a static method of a class is invoked.
3) a static field of Class is assigned.
4) a static field of a class is used which is not a constant variable.
5) if Class is a top-level class and an assert statement lexically nested within the class is executed.

How Class is initialized in Java
Its also important to know in which order various fields (static and non-static), block (static an non static), various classes (subclass and superclass) and various interfaces (sub interface, implementation class and super interface) is initialized in Java.

1) Classes are initialized from top to bottom so field declared on top initialized before field declared in bottom
2) Super Class is initialized before Sub Class or derived class in Java
3) If Class initialization is triggered due to access of static field, only Class which has declared static field is initialized and it doesn't trigger initialization of super class or sub class even if static field is referenced by Type  of Sub Class, Sub Interface or by implementation class of interface.
4) interface initialization in Java doesn't cause super interfaces to be initialized.
5) static fields are initialized during static initialization of class while non static fields are initialized when an instance of the class is created. It means static fields are initialized before non-static fields in Java.
6) non-static fields are initialized by constructors in Java. sub class constructor implicitly call super class constructor before doing any initialization, which guarantees that non static or instance variables of super class is initialized before sub class.

1. Here class initialization occurs because a static field is accessed which is not a compile time constant. had you declare "familyName" compile time constant using the final keyword in Java (as shown in commented section) class initialization of super class would not have occurred.
2) Only super class is initialized even though the static field is referenced using sub type.

Heap space in Java
whenever we create an object using a new operator or by any other means the object is allocated memory from Heap and When the object dies or garbage collected, memory goes back to Heap space in Java

Java Heap and Garbage Collection
As we know objects are created inside heap memory and Garbage Collection is a process that removes dead objects from Java Heap space and returns memory back to Heap in Java

Java Heap dump
Java Heap dump is a snapshot of Java Heap Memory at a particular time. This is very useful to analyze or troubleshoot any memory leak in Java or any java.lang.OutOfMemoryError.
