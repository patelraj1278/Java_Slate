
========================
#Core Java
========================
Overloading & Overriding
Static binding & Dynamic Binding
Abstract class & Interface
this & super keyword in Java
Private Method
Static Method
Final Method
Exception
String Class
Immutable Class & Object
Comparator & Comparable
Equals & Hashcode Method
Enum
Singleton
Collection Interface
Thread Concept
Transient & Volatile Keyword
Serialization
IO Concept
JDK Version
Dead Lock & Race Condition
JVM
When class is loaded
Design Pattern


Java Pass by Value & Pass by Reference
Composition In Java
Nested classes
Access modifier

DataTypes
Try-Catch-Finally
Member Types : instance variables, class variables, intance method, class method (static) , contructors,initilizer block,class initilizer block, static nested class,inner class,member interface
Object class
Member of Interface

========================
#Concept Hacks
========================

-OOPS Concepts
    -Encapsulation in Java
         Important points about encapsulation in Java.
         1. "Whatever changes encapsulate it" is a famous design principle.
         2. Encapsulation helps in loose coupling and high cohesion of code.
         3. Encapsulation in Java is achieved using access modifiers private, protected, and public.
         4. Factory pattern, Singleton pattern in Java makes good use of Encapsulation.
    -Polymorphism in Java
        -something which can take many forms
        -In Java programming whole concept of interface is based on Polymorphism
        -Java has excellent support of polymorphism in terms of Inheritance, method overloading, and method overriding.
        -Method overriding allows Java to invoke a method based on a particular object at run-time instead of declared type while coding.
        -Method overloading and method overriding use concept of Polymorphism in Java where method name remains the same in two classes but an actual method called by JVM depends upon an object at run time and done by dynamic binding in Java.
    -Inheritance
        -The class which extends another class becomes Child of the class it extends and inherits all its functionality which is not private or package-private given where Child class is created.
        -Java Sub Class IS-A Super class like Mango IS-A Fruit.
        -Inheritance in Java is supported using extends and implements keyword
        -If you do not want to allow Inheritance for your class than you can make it final.
        -Constructor in Java are not inherited by Sub Class. In face Constructors are chained, first statement in constructor is always a call to another constructor, either implicitly or explicitly. If you don't call any other constructor compiler will insert super(), which calls no argument constructor of super class in Java. this keyword represents the current instance of a class and the super keyword represent an instance of super class in Java.
        -Private members of Super class is not visible to Sub class.
        -Java has a special access modifier known as protected which is meant to support Inheritance in Java. Any protected member including protected method and field are only accessible in Child class or Sub class outside the package on which they are declared.
        When to Use Inheritance ?
            -Policy to decide whether to use Inheritance or not is to check "IS-A" relationship. For example, all above examples of Inheritance satisfy IS-A rule e.g. HashSet IS-A Set.
             Conversely if you find HAS-A relationship between two classes than use Composition e.g. Car HAS-A Seat, So Car class should be composed with a Seat and Seat should not extend Car here.
    -Abstraction
        -An abstract class is something which is incomplete and you can not create an instance of the abstract class. If you want to use it you need to make it complete or concrete by extending it. A class is called concrete if it does not contain any abstract method and implements all abstract method inherited from the abstract class or interface it has implemented or extended.
        -An abstract method in Java doesn't have the body , it's just a declaration. In order to use an abstract method, you need to override that method in sub class.
        -when do you use abstraction? ( most important in my view )
            when you know something needs to be there but not sure how exactly it should look like.
        -Abstraction Using Interface in Java.Interfaces are by default abstract and only contains public, static, final constant or abstract methods
        -ABSTRACT - If you know some of the behavior while designing class and that would remain common across all subclasses add that into an abstract class.
        -INTERFACE - you can go for java interface if you only know the name of methods your class should have e.g. for Server it should have start() and stop() method but we don't know how exactly these start and stop method will work.
        -It's not necessary for an abstract class to have abstract method. We can mark a class as abstract even if it doesn't declare any abstract methods.There is only one case where I think abstract class without abstract method can be used is when you need a marker class instead of marker interface
#Class Name
-the public class name must match the file name
-Remember class is a blueprint while objects are real instances
#Method Overloading & Overriding
-Method overloading is resolved using static binding in Java at compile time while method overriding is resolved using dynamic binding in Java at runtime.
-You can not override static, final, and private methods in Java but you can overload static, final, or private methods in Java.
-The overriding method can not throw a higher Exception than the original or overridden method.This means if the original method throws IOException then the overriding method can not throw super class of IOException like Exception but it can throw any sub-class of IOException or simply does not throw an Exception.This rule only applies to check Exception in Java, overridden method is free to throw any unchecked Exception.
-you're allowed to change the return type in the overriding method as long as the new return type is a subtype of the declared return type of the overridden (super class)
class Alpha { Alpha doStuff(char c) { return new Alpha(); } } class Beta extends Alpha { Beta doStuff(char c) { // legal override in Java 1.5 return new Beta(); } }
#Constructor Overloading
-Classical example of Constructor overloading is ArrayList in Java. ArrayList has three constructors one is empty, the other takes a collection object and one takes initial Capacity. these overloaded constructors allow flexibility while creating an ArrayList object.
#Static Binding vs Dynamic Binding
-Static binding in Java occurs during Compile time while Dynamic binding occurs during Runtime.private, final and static methods and variables use static binding and are bonded by the compiler while virtual methods are bonded during runtime based upon runtime object.
-Static binding uses Type(Class in Java)  information for binding while Dynamic binding uses Object to resolve to bind.
-Overloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.
#Interface
-the interface is the only way to implement multiple inheritances at the Type level.
-All variables declared inside interface is implicitly public final variable or constants.
-All abstract,static, default methods declared inside Java Interfaces are implicitly public and abstract.Java 8 onwards, it can have default as well as static methods.It is not mandatory to override the default method in Java
#Abstraction
-An abstract class allows you to create functionality that subclasses can implement or override. An interface only allows you to define functionality, not implement it.And whereas a class can extend only one abstract class, it can take advantage of multiple interfaces.
-An abstract class - Multiple Inheritance is not supported , Interface supports Multiple Inheritance.
-Both top level and nested class can be make abstract in Java
-Diff Abstract vs Interfact -> https://www.tutorialspoint.com/differences-between-abstract-class-and-interface-in-java
-The marker interface in Java interfaces with no field or methods or, in simple words empty interface in java is called a marker interface
Example of marker interface is Serializable, Cloneable, and Remote interface.Looking carefully at marker interfaces in Java, like, Serializable, Cloneable, and Remote, it looks they are used to indicate something to compiler or JVM. So if JVM sees a Class is Serializable, it has done some special operation on it, a similar way, if JVM sees one Class is implement Cloneable, it performs some operation to support cloning.
#this Keyword
-"this" keyword can not be used in static context.this is a final variable in Java and you can not assign value to this. this will result in a compilation error:
#Private Keyword
-Private members (both fields and methods) are only accessible inside class they are declared or inside inner classes.
-Top level classes can not be private in Java.
-private methods are well encapsulated in class
-you cannot override private methods in Java
-private keyword can be applied to fields, methods and inner class in Java.
-private methods or variables are not accessible outside of Class, they can be accessed via reflection by using setAccessible(true) and changing there private visibility.
-private members allows Compiler and JVM to optimize it for better performance.
#Static Variable,Static Method,Static Nested Class in Java
-Can create static method, static class and static variable in Java
-static keyword is like any other keyword a simple keyword which can be applied to Java method , nested class or member variable inside a class. static variable in Java belong to whole Class than individual Object
-there is only one copy of static variable will be present in Java Heap memory, which can be accessed or altered by any object.
-you can not use non-static variable inside a static method.it will result in compilation error.
-Static variables are bonded using static binding at compile time so they are comparatively faster than there non-static counter part which were bonded during runtime.
-static variable initialized when class is loaded into JVM on the other hand instance variable has a different value for each instance and they get created when an instance of an object is created either by using the new() operator or using reflection like Class.newInstance().So if you try to access a non-static variable without any instance compiler will complain because those variables are not yet created and they don't have any existence until an instance is created and they are associated with any instance
-A static variable is shared by all instances of the class, while an instance variable is unique to each instance of the class.
-A static variable's memory is allocated at compile time, they are loaded at load time and initialized at class initialization time. In the case of an instance variable all of the above is done at run time.
-You can still access any non-static variable inside any static method or block by creating an instance of class in Java and using that instance to reference instance variable. This is the only legitimate way to access non static variable on static context.
-Static fields are initialized at the time of class loading in Java, opposite to instance variable which is initialised when you create instance of a particular class.
-Static keyword can also be used to create static block in Java which holds piece of code to executed when class is loaded in Java.
-Static method can not be overridden in Java as they belong to class and not to object.so if you have same static  method in subclass and super class , method will be invoked based on declared type of object instead of runtime .If you try to override a static method with a non-static method in sub class you will get compilation error.
-Consider making a static variable final in Java to make it constant and avoid changing it from anywhere in the code.
-Nested static class in Java is a static member of any top level class.
-Since to create instance of any nested class you require instance of outer class but that is not required in case of static nested class in Java.You can have an instance of nested static class without any instance of outer class.
-Normally we make a class static in Java when we want a single resource to be shared between all instances
#Mixing - Static and non-static synchronized method Java
-For those who are not familiar static synchronized method locked on class object e.g. for string class, it's String.class while instance synchronized method locks on the current instance of Object denoted by “this” keyword in Java.Since both of these objects are different they have a different lock so while one thread is executing the static synchronized method, the other thread in java doesn’t need to wait for that thread to return instead it will acquire a separate lock denoted byte .class literal and enter into the static synchronized method.
public class SynchornizationMistakes {
    private static int count = 0;

    //locking on this object lock
    public synchronized int getCount(){
        return count;
    }

    //locking on .class object lock
    public static synchronized void increment(){
        count++;
    }
}
#Final Keyword in Java
-Once you make a reference final you are not allowed to change that reference and compiler will verify this and raise a compilation error if you try to re-initialized final variables in Java.
-Final variables are by default read-only.
-A Java method with the final keyword is called a final method and it can not be overridden in the subclass.You should make a method final in Java if you think it’s complete and its behavior should remain constant in sub-classes.
-Java class with the final modifier is called the final class in Java. The final class is complete in nature and can not be sub-classed or inherited.
-Final keyword improves performance. Not just JVM can cache the final variables but also applications can cache frequently use final variables
-Final variables are safe to share in a multi-threading environment without additional synchronization overhead.
-Final keyword allows JVM to an optimized method, variable or class.
-Final keyword helps to write an immutable class. Immutable classes are the one which can not be modified once it gets created and String is a primary example of an immutable and final class
-The local final variable must be initialized during declaration.
-All variables declared inside the Java interface are implicitly final
-Final and abstract are two opposite keywords and a final class can not be abstract in Java.
-Final methods are bonded during compile time also called static binding.
-Making a collection reference variable final means only reference can not be changed but you can add, remove or change object inside collection.
private final List loans = new ArrayList();
loans.add(“home loan”);  //valid
loans.add("personal loan"); //valid
loans = new Vector();  //not valid
#Checked vs Unchecked Exception in Java
-Checked Exception in Java is all those Exception which requires being catches and handled during compile time.
-All the Exception which are direct sub Class of Exception but not inherit RuntimeException are Checked Exception.
-Example of checked Exception in Java API
 Following are some Examples of Checked Exception in Java library:
 IOException
 SQLException
 DataAccessException
 ClassNotFoundException
 InvocationTargetException
-Unchecked Exception in Java is those Exceptions whose handling is not verified during Compile time. Unchecked Exceptions mostly arise due to programming errors like accessing the method of a null object, accessing elements outside an array bonding, or invoking methods with illegal arguments.
Example of unchecked Exception in Java API
Here are few examples of Unchecked Exception in Java library:
NullPointerException
ArrayIndexOutOfBound
IllegalArgumentException
IllegalStateException
#How to write immutable class in Java
-This Java class is immutable because its state can not be changed once created. You can see that all of it’s fields are final.
-Immutable objects are by default thread safe, can be shared without synchronization in concurrent environment.
-An immutable object simplifies development, because its easier to share between multiple threads without external synchronization.
#Comparator vs Comparable
-compareTo in Java is in the same league of equals() and hashcode() and used to implement natural order of object, compareTo is slightly different to compare() method of Comparator interface which is used to implement custom sorting order.
-compareTo() method is defined in interface java.lang.Comparable and it is used to implement natural sorting on java classes. natural sorting means the sort order which naturally applies on object e.g. lexical order for String, numeric order for Integer or Sorting employee by there ID, etc
-CompareTo method must return negative number if current object is less than other object, positive number if current object is greater than other object and zero if both objects are equal to each other.
#Equal and Hashcode
-equals() method is used to compare Objects for equality while hashCode is used to generate an integer code corresponding to that object.
-Default implementation of equals() class provided by java.lang.Object compares memory location and only return true if two reference variable is pointing to the same memory location i.e. essentially they are the same object.
-HashMap and Hashtable in Java rely on the equals() and hashCode() method for comparing keys and values

#Equals and hashCode contract in Java
Equals Rule
1) Reflexive: Object must be equal to itself.
2) Symmetric : if a.equals(b) is true then b.equals(a) must be true.
3) Transitive : if a.equals(b) is true and b.equals(c) is true then c.equals(a) must be true.
if((obj == null) || (obj.getClass() != this.getClass())) { return false; }

Hashcode Rule
1) If two objects are equal by equals() method then there hashcode must be same.
2) If two objects are not equal by equals() method then there hashcode could be same or different.


#Enum
-A feature that is used to represent a fixed number of well-known values in Java
-The best feature of Enum is you can use Enum in Java inside Switch statements like int or char primitive data type.
-Two new collection classes EnumMap and EnumSet are added to the collection package to support Java Enum.These classes are a high-performance implementation of the Map and Set interface in Java and we should use this whenever there is an opportunity.
Enum in Java is type-safe, provides meaningful String names and has their own namespace
Enum constants - Enum constants are implicitly static and final and you can not change their value once created.
Enum is type-safe you can not assign anything else other than predefined Enum constants to an Enum variable. It is a compiler error to assign something else
Enum in Java are reference types like class or interface and you can define constructor, methods, and variables inside java Enum which makes it more powerful than Enum
Enum - Variable
Enum - Method
Enum - Constructor - The constructor of the enum in java must be private any other access modifier will result in a compilation error.You can not create an instance of enums by using a new operator
Enum Instance - An instance of Enum in Java is created when any Enum constants are first called or referenced in code.
Enum Interface - An instance of Enum in Java is created when any Enum constants are first called or referenced in code.
Enum Abstract Method - You can define abstract methods inside Enum in Java.and can also provide a different implementation for different instances of enum in java.
Enum built-in Method - Enum has so many useful built-in methods like values(), the valueOf(), name(), and ordinal(),
Enum can override methods also.
Real-world Examples of Enum in Java - Enum as Thread Safe Singleton,Strategy Pattern using Enum,Enum as replacement of Enum String or int pattern,Enum as State Machine

#Singleton
-Singleton is a class which has only one instance in whole application and provides a getInstance() method to access the singleton instance.
There are many classes in JDK which is implemented using Singleton pattern like java.lang.Runtime which provides getRuntime() method to get access of it and used to get free memory and total memory in Java.
-Since locking only make sense when we need to create instance and rest of the time its just read only access so locking of critical section is always better option.synchronization is costly and when you apply this on whole method than call to getInstance() will be synchronized and contented.
-there are many ways to implement Singleton like using double checked locking or Singleton class with static final instance initialized during class loading. Former is called lazy loading because Singleton instance is created only when client calls getInstance() method while later is called early loading because Singleton instance is created when class is loaded into memory.
Double checked locking is a technique to prevent creating another instance of Singleton when call to getInstance() method is made in multi-threading environment. In Double checked locking pattern as shown in below example, singleton instance is checked two times before initialization.
public static Singleton getInstance(){
     if(_INSTANCE == null){
         synchronized(Singleton.class){
         //double checked locking - because second check of Singleton instance with lock
                if(_INSTANCE == null){
                    _INSTANCE = new Singleton();
                }
            }
         }
     return _INSTANCE;
}
Ways to create Singleton -
1)Double checked locking should only be used when you have requirement for lazy initialization
2)use Enum to implement singleton or simple static final variable.
3)Preferred way is not to implement Cloneable interface as why should one wants to create clone() of Singleton and if you do just throw Exception from clone() method as “Can not create clone of Singleton class”.
4)Since constructor of Singleton class is supposed to be private it prevents creating instance of Singleton from outside but Reflection can access private fields and methods, which opens a threat of another instance. This can be avoided by throwing Exception from constructor as “Singleton already initialized”

How many ways you can write Singleton Class in Java?
Answer : I know at least four ways to implement Singleton pattern in Java
Singleton by synchronizing getInstance() method
Singleton with public static final field initialized during class loading.
Singleton generated by static nested class, also referred as Singleton holder pattern.
From Java 5 on-wards using Enums

