-OOPS Concepts
    -Encapsulation in Java
         Important points about encapsulation in Java.
         1. "Whatever changes encapsulate it" is a famous design principle.
         2. Encapsulation helps in loose coupling and high cohesion of code.
         3. Encapsulation in Java is achieved using access modifiers private, protected, and public.
         4. Factory pattern, Singleton pattern in Java makes good use of Encapsulation.
    -Polymorphism in Java
        -something which can take many forms
        -In Java programming whole concept of interface is based on Polymorphism
        -Java has excellent support of polymorphism in terms of Inheritance, method overloading, and method overriding.
        -Method overriding allows Java to invoke a method based on a particular object at run-time instead of declared type while coding.
        -Method overloading and method overriding use concept of Polymorphism in Java where method name remains the same in two classes but an actual method called by JVM depends upon an object at run time and done by dynamic binding in Java.
    -Inheritance
        -The class which extends another class becomes Child of the class it extends and inherits all its functionality which is not private or package-private given where Child class is created.
        -Java Sub Class IS-A Super class like Mango IS-A Fruit.
        -Inheritance in Java is supported using extends and implements keyword
        -If you do not want to allow Inheritance for your class than you can make it final.
        -Constructor in Java are not inherited by Sub Class. In face Constructors are chained, first statement in constructor is always a call to another constructor, either implicitly or explicitly. If you don't call any other constructor compiler will insert super(), which calls no argument constructor of super class in Java. this keyword represents the current instance of a class and the super keyword represent an instance of super class in Java.
        -Private members of Super class is not visible to Sub class.
        -Java has a special access modifier known as protected which is meant to support Inheritance in Java. Any protected member including protected method and field are only accessible in Child class or Sub class outside the package on which they are declared.
        When to Use Inheritance ?
            -Policy to decide whether to use Inheritance or not is to check "IS-A" relationship. For example, all above examples of Inheritance satisfy IS-A rule e.g. HashSet IS-A Set.
             Conversely if you find HAS-A relationship between two classes than use Composition e.g. Car HAS-A Seat, So Car class should be composed with a Seat and Seat should not extend Car here.
    -Abstraction
        -An abstract class is something which is incomplete and you can not create an instance of the abstract class. If you want to use it you need to make it complete or concrete by extending it. A class is called concrete if it does not contain any abstract method and implements all abstract method inherited from the abstract class or interface it has implemented or extended.
        -An abstract method in Java doesn't have the body , it's just a declaration. In order to use an abstract method, you need to override that method in sub class.
        -when do you use abstraction? ( most important in my view )
            when you know something needs to be there but not sure how exactly it should look like.
        -Abstraction Using Interface in Java.Interfaces are by default abstract and only contains public, static, final constant or abstract methods
        -ABSTRACT - If you know some of the behavior while designing class and that would remain common across all subclasses add that into an abstract class.
        -INTERFACE - you can go for java interface if you only know the name of methods your class should have e.g. for Server it should have start() and stop() method but we don't know how exactly these start and stop method will work.
        -It's not necessary for an abstract class to have abstract method. We can mark a class as abstract even if it doesn't declare any abstract methods.There is only one case where I think abstract class without abstract method can be used is when you need a marker class instead of marker interface









Overloading & Overriding
Static binding & Dynamic Binding
Abstract class & Interface
this & super keyword in Java
Private Method
Static Method
Final Method
Exception
String Class
Immutable Class & Object
Comparator & Comparable
Equals & Hashcode Method
Enum
Singleton
Collection Interface
Thread Concept
Transient & Volatile Keyword
Serialization
IO Concept
JDK Version
Dead Lock & Race Condition
JVM
When class is loaded
Design Pattern


Java Pass by Value & Pass by Reference
Composition In Java
Nested classes
Access modifier

DataTypes
Try-Catch-Finally
Member Types : instance variables, class variables, intance method, class method (static) , contructors,initilizer block,class initilizer block, static nested class,inner class,member interface
Object class
Member of Interface


#Concept Hacks

#Class Name
-the public class name must match the file name
-Remember class is a blueprint while objects are real instances
#Method Overloading & Overriding
-Method overloading is resolved using static binding in Java at compile time while method overriding is resolved using dynamic binding in Java at runtime.
-You can not override static, final, and private methods in Java but you can overload static, final, or private methods in Java.
-The overriding method can not throw a higher Exception than the original or overridden method.This means if the original method throws IOException then the overriding method can not throw super class of IOException like Exception but it can throw any sub-class of IOException or simply does not throw an Exception.This rule only applies to check Exception in Java, overridden method is free to throw any unchecked Exception.
-you're allowed to change the return type in the overriding method as long as the new return type is a subtype of the declared return type of the overridden (super class)
class Alpha { Alpha doStuff(char c) { return new Alpha(); } } class Beta extends Alpha { Beta doStuff(char c) { // legal override in Java 1.5 return new Beta(); } }
#Constructor Overloading
-Classical example of Constructor overloading is ArrayList in Java. ArrayList has three constructors one is empty, the other takes a collection object and one takes initial Capacity. these overloaded constructors allow flexibility while creating an ArrayList object.
#Static Binding vs Dynamic Binding
-Static binding in Java occurs during Compile time while Dynamic binding occurs during Runtime.private, final and static methods and variables use static binding and are bonded by the compiler while virtual methods are bonded during runtime based upon runtime object.
-Static binding uses Type(Class in Java)  information for binding while Dynamic binding uses Object to resolve to bind.
-Overloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.
#Interface
-the interface is the only way to implement multiple inheritances at the Type level.
-All variables declared inside interface is implicitly public final variable or constants.
-All methods declared inside Java Interfaces are implicitly public and abstract.Java 8 onwards, it can have default as well as static methods.
#Abstraction
-An abstract class allows you to create functionality that subclasses can implement or override. An interface only allows you to define functionality, not implement it.And whereas a class can extend only one abstract class, it can take advantage of multiple interfaces.
-An abstract class - Multiple Inheritance is not supported , Interface supports Multiple Inheritance.
-Both top level and nested class can be make abstract in Java
-Diff Abstract vs Interfact -> https://www.tutorialspoint.com/differences-between-abstract-class-and-interface-in-java
-The marker interface in Java interfaces with no field or methods or, in simple words empty interface in java is called a marker interface
Example of marker interface is Serializable, Cloneable, and Remote interface.Looking carefully at marker interfaces in Java, like, Serializable, Cloneable, and Remote, it looks they are used to indicate something to compiler or JVM. So if JVM sees a Class is Serializable, it has done some special operation on it, a similar way, if JVM sees one Class is implement Cloneable, it performs some operation to support cloning.
#this Keyword
-"this" keyword can not be used in static context.this is a final variable in Java and you can not assign value to this. this will result in a compilation error:
#Private Keyword
-Private members (both fields and methods) are only accessible inside class they are declared or inside inner classes.
-Top level classes can not be private in Java.
#Static Variable,Static Method,Static Nested Class in Java
-Can create static method, static class and static variable in Java
-static keyword is like any other keyword a simple keyword which can be applied to Java method , nested class or member variable inside a class. static variable in Java belong to whole Class than individual Object
-there is only one copy of static variable will be present in Java Heap memory, which can be accessed or altered by any object.
-you can not use non-static variable inside a static method.it will result in compilation error.
-Static variables are bonded using static binding at compile time so they are comparatively faster than there non-static counter part which were bonded during runtime.
-static variable initialized when class is loaded into JVM on the other hand instance variable has a different value for each instance and they get created when an instance of an object is created either by using the new() operator or using reflection like Class.newInstance().So if you try to access a non-static variable without any instance compiler will complain because those variables are not yet created and they don't have any existence until an instance is created and they are associated with any instance
-You can still access any non-static variable inside any static method or block by creating an instance of class in Java and using that instance to reference instance variable. This is the only legitimate way to access non static variable on static context.
-Static fields are initialized at the time of class loading in Java, opposite to instance variable which is initialised when you create instance of a particular class.
-Static keyword can also be used to create static block in Java which holds piece of code to executed when class is loaded in Java.
-Static method can not be overridden in Java as they belong to class and not to object.so if you have same static  method in subclass and super class , method will be invoked based on declared type of object instead of runtime .If you try to override a static method with a non-static method in sub class you will get compilation error.
-Consider making a static variable final in Java to make it constant and avoid changing it from anywhere in the code.
-Nested static class in Java is a static member of any top level class.
-Since to create instance of any nested class you require instance of outer class but that is not required in case of static nested class in Java.You can have an instance of nested static class without any instance of outer class.
-Normally we make a class static in Java when we want a single resource to be shared between all instances
